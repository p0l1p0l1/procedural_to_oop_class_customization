# -*- coding: utf-8 -*-
"""Poliaeva Exercise 2: Procedural to OOP & Class customization.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1h7aFfhrmPusNkdNi0CQ4miEjh_GjF0HE
"""

import math

class Canvas:
  def __init__(self, width: int, height: int):
    self.canvas = [" " * width for _ in range(height)]

  def print(self):
    def create_row_headers(length: int):
        return "".join([str(i % 10) for i in range(length)])
    header = " " + create_row_headers(len(self.canvas[0]))
    print(header)
    for idx, row in enumerate(self.canvas):
        print(idx % 10, row, idx % 10, sep="")
    print(header)

  def draw_polygon(self, *points: tuple[int, int], closed: bool = True, line_char: str = "*"):
    def draw_line_segment(canvas, start: tuple[int, int], end: tuple[int, int], line_char: str = "*"):
        def replace_at_index(s: str, r: str, idx: int) -> str:
            return s[:idx] + r + s[idx + len(r):]

        x1, y1 = start
        x2, y2 = end

        dx = abs(x2 - x1)
        dy = abs(y2 - y1)
        sx = 1 if x1 < x2 else -1
        sy = 1 if y1 < y2 else -1
        error = dx - dy

        while x1 != x2 or y1 != y2:
            self.canvas[y1] = replace_at_index(self.canvas[y1], line_char, x1)

            double_error = error * 2
            if double_error > -dy:
                error -= dy
                x1 += sx

            if double_error < dx:
                error += dx
                y1 += sy

        self.canvas[y2] = replace_at_index(self.canvas[y2], line_char, x2)

    start_points = points[:-1]
    end_points = points[1:]

    if closed:
        start_points += (points[-1],)
        end_points += (points[0],)

    for start_point, end_point in zip(start_points, end_points):
        draw_line_segment(self.canvas, start_point, end_point, line_char)

  def draw_line(self, start: tuple[int, int], end: tuple[int, int], line_char: str = "*"):
    self.draw_polygon(start, end, closed=False, line_char=line_char)


  def draw_rectangle(self, upper_left: tuple[int, int], lower_right: tuple[int, int], line_char: str = "*"):
    x1, y1 = upper_left
    x2, y2 = lower_right

    self.draw_polygon(upper_left, (x2, y1), lower_right, (x1, y2), line_char=line_char)


  def draw_n_gon(self, center: tuple[int, int], radius: int, number_of_points: int, rotation: int = 0, line_char: str = "*"):
    angles = range(rotation, 360 + rotation, 360 // number_of_points)
    points = []
    for angle in angles:
        # Convert the angle of the point to radians
        angle_in_radians = math.radians(angle)
        # Calculate the x and y positions of the point
        x = center[0] + radius * math.cos(angle_in_radians)
        y = center[1] + radius * math.sin(angle_in_radians)
        # Add the point to the list of points as a tuple
        points.append((round(x), round(y)))

    # Use the draw_polygon function to draw all the lines of the n-gon
    self.draw_polygon(*points, line_char="o")


canvas = Canvas(100, 40)
canvas.draw_polygon((7, 12), (24, 29), (42, 15), (37, 32), (15, 35))
canvas.draw_line((10, 4), (92, 19), "+")
canvas.draw_rectangle((45, 2), (80, 27), line_char='#')
canvas.draw_n_gon((72, 25), 12, 20, 80, "-")
canvas.print()
print("")


class Point:
    def __init__(self, x: float, y: float):
      self.x = x
      self.y = y

    def  __repr__(self):
      return f"({self.x}, {self.y})"

    def distance_from_origin(points: tuple[float, float]):
      return (points[0]**2 + points[1]**2)**(1/2)

class Shape:
    def __init__(self, *points: tuple[int, int]):
      self.shape = list(points)

    def  __repr__(self):
      return f"{self.shape}"

    def centroid(self) -> Point:
      x, y = 0, 0
      for coordinate in self.shape:
        coordinate = str(coordinate).replace("(", "").replace(")", "").split(",")
        x += float(coordinate[0])
        y += float(coordinate[1])
      return (x/len(self.shape), y/len(self.shape))

    def __eq__(self, other):
      return (Point.distance_from_origin(self.centroid()) == Point.distance_from_origin(other.centroid()))

    def __lt__(self, other):
      return (Point.distance_from_origin(self.centroid()) < Point.distance_from_origin(other.centroid()))

s1 = Shape(Point(0, 0), Point(0, 1), Point(1, 1), Point(1, 0))
s2 = Shape(Point(0, 0.5), Point(0.5, 1), Point(1, 0.5), Point(0.5, 0))
print(s1 == s2) # Equal because the two have the same centroid
s2 = Shape(Point(5, 5), Point(5, 6), Point(6, 6), Point(6, 5))
print(s1 < s2) # s1 is smaller than s2 because its centroid is closer
s3 = Shape(Point(10, 10), Point(10, 11), Point(11, 11), Point(11, 10))
shapes = [s3, s1, s2]
print(shapes)
print(sorted(shapes)) # sorted by their distance from the origin